import { useEffect, useMemo, useRef, forwardRef } from 'react';
import * as THREE from 'three';
import { extend } from '@react-three/fiber';
import { PlanetMaterial } from './PlanetMaterial';
// eslint-disable-next-line @typescript-eslint/no-unused-vars
import { ITerrainChunkProps, Y_OFFSET, TERRAIN_PROPS } from '@/Constants';
// import { useGameStore } from '@/Controllers/Game/GameController';
import { useTexture } from '@react-three/drei';
import { QuadtreeNode } from './quadTree';

extend({ PlanetMaterial });

// const Planet = forwardRef<THREE.Mesh, ITerrainChunkProps>(function Planet(
//   {
//     worldOrigin = new THREE.Vector2(0, 0),
//     position = new THREE.Vector3(0, Y_OFFSET, 0),
//     size = TERRAIN_PROPS.size,
//     segments = TERRAIN_PROPS.segments,
//     maxHeight = TERRAIN_PROPS.maxHeight,
//     frequency = TERRAIN_PROPS.frequency,
//     amplitude = TERRAIN_PROPS.amplitude,
//     octaves = TERRAIN_PROPS.octaves,
//     lacunarity = TERRAIN_PROPS.lacunarity,
//     persistence = TERRAIN_PROPS.persistence,
//     exponentiation = TERRAIN_PROPS.exponentiation,
//     midMapPath = TERRAIN_PROPS.midMapPath,
//     highMapPath = TERRAIN_PROPS.highMapPath,
//     lowMapPath = TERRAIN_PROPS.lowMapPath,
//   },
//   ref,
// ) {
//   const materialRef = useRef<PlanetMaterial>(null);
//   const geometryRef = useRef<THREE.PlaneGeometry | null>(null);
//   const setMaterialLoaded = useGameStore((state) => state.setMaterialLoaded);
//   const [midTexture, lowTexture, highTexture] = useTexture([lowMapPath, midMapPath, highMapPath]);

//   [midTexture, lowTexture, highTexture].forEach((tex) => {
//     tex.wrapS = THREE.RepeatWrapping;
//     tex.wrapT = THREE.RepeatWrapping;
//     // tex.anisotropy = renderer.capabilities.getMaxAnisotropy(); // only works if you have access
//     tex.needsUpdate = true;
//   });

//   const geometry = useMemo(() => {
//     const geom = new THREE.PlaneGeometry(size, size, segments, segments);
//     geom.rotateX(-Math.PI / 2);
//     geom.computeVertexNormals();
//     geometryRef.current = geom;
//     return geom;
//   }, [size, segments]);

//   useEffect(() => {
//     return () => {
//       if (geometryRef.current) {
//         geometryRef.current.dispose();
//         geometryRef.current = null;
//       }
//     };
//   }, []);

//   useEffect(() => {
//     if (!materialRef.current || !midTexture) return;
//     materialRef.current.customUniforms.map.value = midTexture;
//     materialRef.current.customUniforms.lowMap.value = lowTexture;
//     materialRef.current.customUniforms.highMap.value = highTexture;
//     materialRef.current.needsUpdate = true;
//   }, [highTexture, lowTexture, midTexture]);

//   useEffect(() => {
//     if (materialRef.current) {
//       materialRef.current.onShaderCompiled = () => {
//         if (!useGameStore.getState().MaterialLoaded) {
//           setMaterialLoaded(true);
//         }
//       };
//     }
//     const material = materialRef.current;
//     return () => {
//       if (material) {
//         material.onShaderCompiled = undefined;
//       }
//     };
//   }, [setMaterialLoaded]);

//   useEffect(() => {
//     if (!materialRef.current) return;

//     if (materialRef.current.userData.shader && !useGameStore.getState().MaterialLoaded) {
//       setMaterialLoaded(true);
//     }

//     const uniforms = materialRef.current.customUniforms;

//     uniforms.uMaxHeight.value = maxHeight;
//     uniforms.uFrequency.value = frequency;
//     uniforms.uAmplitude.value = amplitude;
//     uniforms.uOctaves.value = octaves;
//     uniforms.uLacunarity.value = lacunarity;
//     uniforms.uPersistence.value = persistence;
//     uniforms.uExponentiation.value = exponentiation;

//     uniforms.uWorldOffset.value.set(position.x - worldOrigin.x, position.z - worldOrigin.y);
//     uniforms.uWorldOrigin.value.set(worldOrigin.x, worldOrigin.y);
//   }, [
//     maxHeight,
//     frequency,
//     amplitude,
//     octaves,
//     lacunarity,
//     persistence,
//     exponentiation,
//     position,
//     worldOrigin,
//     setMaterialLoaded,
//   ]);

//   return (
//     <mesh ref={ref} position={[0, 0, 0]} castShadow receiveShadow geometry={geometry}>
//       <planetMaterial ref={materialRef} attach="material" side={THREE.DoubleSide} />
//     </mesh>
//   );
// });

// export default Planet;

// --- Chunk.tsx (Refactored Planet.tsx) ---
// This component represents a single piece of the terrain generated by a QuadtreeNode.
// It uses the custom PlanetMaterial to deform the geometry and apply textures.
interface IChunkProps {
  node: QuadtreeNode;
  worldOrigin: THREE.Vector2;
}

export const Chunk = forwardRef<THREE.Mesh, IChunkProps>(function Chunk(
  { node, worldOrigin },
  ref,
) {
  const materialRef = useRef<PlanetMaterial>(null);
  const { position, size, segments } = useMemo(() => {
    // Determine the position and size from the quadtree node.
    const pos = new THREE.Vector3(node.center.x, Y_OFFSET, node.center.y);
    const s = node.size;
    const segs = Math.max(2, Math.floor(s / (TERRAIN_PROPS.size / TERRAIN_PROPS.segments)));
    return { position: pos, size: s, segments: segs };
  }, [node]);

  const geometry = useMemo(() => {
    const geom = new THREE.PlaneGeometry(size, size, segments, segments);
    geom.rotateX(-Math.PI / 2);
    geom.computeVertexNormals();
    return geom;
  }, [size, segments]);

  const [midTexture, lowTexture, highTexture] = useTexture([
    TERRAIN_PROPS.midMapPath,
    TERRAIN_PROPS.lowMapPath,
    TERRAIN_PROPS.highMapPath,
  ]);

  useEffect(() => {
    if (!materialRef.current) return;
    materialRef.current.customUniforms.map.value = midTexture;
    materialRef.current.customUniforms.lowMap.value = lowTexture;
    materialRef.current.customUniforms.highMap.value = highTexture;
    materialRef.current.needsUpdate = true;
  }, [highTexture, lowTexture, midTexture]);

  useEffect(() => {
    if (!materialRef.current) return;
    const uniforms = materialRef.current.customUniforms;
    uniforms.uMaxHeight.value = TERRAIN_PROPS.maxHeight;
    uniforms.uFrequency.value = TERRAIN_PROPS.frequency;
    uniforms.uAmplitude.value = TERRAIN_PROPS.amplitude;
    uniforms.uOctaves.value = TERRAIN_PROPS.octaves;
    uniforms.uLacunarity.value = TERRAIN_PROPS.lacunarity;
    uniforms.uPersistence.value = TERRAIN_PROPS.persistence;
    uniforms.uExponentiation.value = TERRAIN_PROPS.exponentiation;
    uniforms.uWorldOffset.value.set(position.x - worldOrigin.x, position.z - worldOrigin.y);
    uniforms.uWorldOrigin.value.set(worldOrigin.x, worldOrigin.y);
  }, [position, worldOrigin]);

  return (
    <mesh ref={ref} position={[0, 0, 0]} castShadow receiveShadow geometry={geometry}>
      <planetMaterial ref={materialRef} attach="material" side={THREE.DoubleSide} />
    </mesh>
  );
});
